package Google;

/**
 *
 第一轮：family trees里，给定任意两个节点，找出是否有blood relationship（看两个节点是否有共同的祖先）
 第二轮：已知一个linked list，给出linked list中的若干个节点，问这些节点中能够组成多少个直接相连的group。例如：1->2->3->4->5->6, (1,3,4,6)可以组成三个group
 第三轮：对N个小灯泡，实现两个method：1.isOn(int i)：判断第i个灯泡ON/OFF， 2.toggle(int start, int end, boolean on)：turn on/off 从第start开始到end结束的灯泡
 第四轮：给定一个整数N，从0开始，每次增加2^i， i为任意整数，直到增加至N。打印从0到N的所有可能的路径。例如: N=4， 结果为：[0,1,2,3,4], [0,1,2,4], [0,1,3,4], [0,2,4], [0,2,3,4], [0,4]
 第五轮：给一个matrix，判断是否为沿对角线对称矩阵。follow up：single node上memory有限的情况如何优化算法，distributed cluster上如何优化。
 *
 *
 已知一个linked list，给出linked list中的若干个节点，问这些节点中能够组成多少个直接相连的group。例如：1->2->3->4->5->6, (1,3,4,6)可以组成三个group



 Given a few nodes in a linked list, find how many groups of connected nodes there is.


 */
public class LinkedListGroups {
}
